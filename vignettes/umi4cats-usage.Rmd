---
title: "Analyzing UMI-4C data with UMI4Cats"
author: "Mireia Ramos-Rodríguez & Marc Subirana-Granés"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    fig_width: 6
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{Analyzing UMI-4C data with UMI4Cats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

# Introduction

![](../man/figures/logo.png)

Hello stranger! If you are here, that means you've successfully completed the UMI-4C protocol and got some sequencing results.

```{r}
library(UMI4Cats)
```

# Quick start
## Processing FASTQ files

```{r processing-quick-start, eval=FALSE}
## 1) Setup python virtual environment & dependencies -----
py_umi4cats <- "~/venvs/umi4cats" 
installVenv(py_umi4cats)

## 2) Generate Digested genome ----------------------------
# The selected RE in this case is DpnII (|GATC), so the cs5p is "" and cs3p is GATC
hg19_dpnii <- digestGenome(cs5p="", 
                           cs3p="GATC", 
                           nameRe="dpnII", 
                           refgen=BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19, 
                           output="digested_genome/")

## 3) Process UMI-4C fastq files --------------------------
raw_dir <- "../package_samples/raw/"
py_umi4cats <- '~/tools/venv_umi4cats_retest'

## Run main function
contactsUMI4C(fastq_dir=raw_dir,
              wk_dir="SOCS1",
              bait_seq="CCCAAATCGCCCAGACCAG",
              bait_pad="GCGCG",
              res_enz="GATC",
              cut_pos=0,
              digested_genome=hg19_dpnii,
              ref_gen="/biodata/indices/species/Hsapiens/ucsc.hg19.fa",
              threads=5,
              path_venv=py_umi4cats)

## 4) Get filtering and alignment stats ---------
satsUMI4C(fastq_dir=raw_dir,
          wk_dir="SOCS1")
``` 


## Analyzing UMI-4C results
```{r analysis-quick-start, eval=FALSE}
# Load sample processed file paths
files <- list.files(system.file("extdata", "wk_dir", 
                                package="UMI4Cats"),
                    pattern="*.tsv",
                    full.names=TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub(".tsv", "", basename(files)),
                      replicate = unlist(lapply(strsplit(basename(files), "_"), 
                                                function(x) x[2])),
                      condition = unlist(lapply(strsplit(basename(files), "_"), 
                                                function(x) x[1])),
                      file = files,
                      stringsAsFactors=F)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData=colData,
                 viewpoint_name="SOCS1")

# Perform differential test
umi <- fisherUMI4C(umi)

# Plot results
plotUMI4C(umi)
```


# Processing UMI-4C FASTQ files

## Installing python dependencies

UMI4Cats package requires some python dependencies. For this reason is necessary create a pyhton virtualenv with all the required modules. The required modules are defined in the python/requirements.txt. To ensure proper functioning the virtual environment should be named and placed in python/umi4catsVenv. How ever, is possible to automatically generate this virtual environment using the `installVenv()` function:

```{r, eval=FALSE}
# Install and set up all python dependencies
installVenv(path)
```

## Reference genome digestion

For analysing the fastq UMI4c data is necessary a genome track of the desired restriction enzyme. Using `digestGenome()` function is possible to generate this genome track. The function is based on BSgenome and the name of the desired reference genome have to be in BSgenome format as the function description sets. 

```{r, eval=FALSE}
library(BSgenome.Hsapiens.UCSC.hg19)
refgen <- BSgenome.Hsapiens.UCSC.hg19
output <- '~/refgen/genomicTracksR'
cs5p <- ""
cs3p <- "GATC"

hg19_dpnii <- digestGenome(cut_seq_5p=cs5p, 
                           cut_seq_3p=cs3p, 
                           name_RE="DpnII", 
                           refgen=refgen, 
                           out_path=output)
# Returns path for the digested genome
```


## Fastq demultiplex

UMI4Cats packages provide a fastq-multx parser for demultiplexing paired-end fastq files. Barcodes and sample names have to be provided as the following example shows. 

```{r, eval=FALSE}
barcodes <- data.frame(sample=c("KLK3", "KLK6", "KLK7", "KLK10"),
                      barcode=c("ATGGTCTGGGCGCTGTCTTG",
                                "TATTCTTCCTCAGCCCACATCTT",
                                "GGATGAAGATTTTGGAGCCCAGC",
                                "GGGCGGGGATTGAACGC"))

demultiplexFastq(barcodes=barcodes,
                fastq="~/samples/sample_1_R1.fastq.gz",
                type="paired",
                out_path="raw_fastq")
```

## UMI-4C contact counts 

UMI4C counts for the viewpoint and the surrounding chromatin are generated. The paired-end sequence for a defined viewpoint and restriction enzyme are parsed, splitted according to the restriction enzyme, aligned and the UMI4C are generated.

All the samples with the same viewpoint - restriction enzyme can be analysed together saving it in the raw_dir. 

```{r}
raw_dir <- system.file("extdata", "raw_dir", package = "UMI4Cats")
wk_dir <- "wk_dir"
```


For every viewpoint - restriction enzyme analysis the bait sequence and pad, and the restriction enzyme sequence have to be defined. Moreover, is necessary to define the restiction enzyme cutting postion being the zero-base nucleotide where restriction enzyme cuts. In the case of Csp6I (G|TAC), the cutting position is 1. 

```{r}
## Bait info
bait_seq <- 'CCCAAATCGCCCAGACCAG'
bait_pad <- 'GCGCGGATC'
res_e <- 'GATC' 
cut_pos <- 0 
```

UMI4Cats uses some external tools. The path of these external tools have to be defined, aside from referenge genome, genome track and python virtual environment paths.  

```{r}
bowtie2 <- 'bowtie2'
samtools <- 'samtools'
ref_gen <- '/imppc/labs/lplab/share/marc/refgen/hg19/hg19.fa'
```


Finally, running the main function `contactsUMI4C()` the analysis for every sample in the raw_dir will be carried out. The output (UMI4C counts) is a tsv file saved in wk_dir/rst. This file will be used in the analyzing part.


```{r}
contactsUMI4C(path_venv=py_umi4cats,
                 raw_dir=raw_dir,
                 wk_dir=wk_dir,
                 threads=1,
                 bait_seq=bait_seq,
                 bait_pad=bait_pad,
                 res_e=res_e,
                 ref_gen=ref_gen,
                 genomic_track=hg19_dpnii,
                 cut_pos=cut_pos)
```

Once finished the contacts anaylsis, the logs of filtering and alignment process can be generated unsing `getLogsUmi4Cats`. The output will be save in the wk_dir/rst folder.

```{r}
getLogsUmi4Cats <- function(raw_dir,
                            wk_dir,
                            threads)
```

# Analyzing UMI-4C data

For this part of the analysis each bait should be analyzed separately. A different `UMI4C` object should be created for each analyzed bait.

## Construct the `UMI4C` object

The first step of the UMI-4C data analysis consists on loading the tables generated by the function `umi4CatsContacts` and use them to construct a `UMI4C`object. All these steps are perform automatically by the `makeUMI4C` functions. 

The `makeUMI4C` will need as imput a data frame (`colData`) containing all relevant experiment information that will be needed for analyzing the data later on. The mandatory columns that this data frame should have are:

1. `sampleID`: Unique identifier for the sample.
2. `replicate`: Replicate identifier or number.
3. `condition`: Condition for performing the diferential analysis. For example: "control" and "treatment", two different cell types, etc. The condition column should only have **two** different values. If more condition variables are provided, the differential analysis will fail.
4. `file`: Complete path and filename where the tsv files generated by `umi4CatsContacts` are saved.

You can also include additional columns to `colData`, but the ones mentioned above are mandatory.

Additionally, the `makeUMI4C` function also contains other arguments that can be used if you want to tweak the default parameters of the analysis. See `?makeUMI4C` to have a complete list and description of all the arguments.

```{r}
# Load sample processed file paths
files <- list.files(system.file("extdata", "wk_dir", 
                                package="UMI4Cats"),
                    pattern="*.tsv",
                    full.names=TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub(".tsv", "", basename(files)),
                      replicate = unlist(lapply(strsplit(basename(files), "_"), 
                                                function(x) x[2])),
                      condition = unlist(lapply(strsplit(basename(files), "_"), 
                                                function(x) x[1])),
                      file = files,
                      stringsAsFactors=F)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData=colData,
                 viewpoint_name="SOCS1")
```


This function contains several basic steps for preparing and analzying the UMI-4C data:

1. Removing fragment ends around the bait. The default value can be changed using the `bait_exclusion` argument.
2. Focusing the scope of the analysis in a specific region around the bait. The default value can be changed using the `bait_expansion` argument.
3. Obtaining the normalization matrices that will be used to scale the samples to the reference sample. If you want to avoid this normalization step, you can set `normalized` to `FALSE`.
4. Calculating the domainograms for each sample.
5. Calculating the adaptative trend for each sample.


### Plotting the `UMI4C` object

Once the `UMI4C` object is created, you can plot it using the `plotUMI4C` function. By default, the function will combine the samples using the **condition** column from `colData(umi)` (the colData data frame you provided for generating the `UMI4C` object), but you can change this behaviour using the `grouping` argument. You can give it one or several column names and will to the grouping based on those variables. For example, if you set `grouping="sampleID"` it will plot the individual profiles. You can group the data using several columns as well.

```{r}
plotUMI4C(umi)

plotUMI4C(umi, grouping="sampleID")

plot(umi, grouping=c("replicate", "condition"))
```


## Quality control plots & summaries

`Under construction`

![](https://media.giphy.com/media/sTmj0aWlMjToc/giphy.gif)


## Perform differential analysis


