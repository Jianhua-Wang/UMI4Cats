---
title: "Analyzing UMI-4C data with UMI4Cats"
author: "Mireia Ramos-Rodríguez & Marc Subirana-Granés"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    fig_width: 6
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{Analyzing UMI-4C data with UMI4Cats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE,
  warning = FALSE,
  message = FALSE
)
```

# Introduction

![](../man/figures/logo.png)

Hello stranger! If you are here, that means you've successfully completed the UMI-4C protocol and got some sequencing results.

```{r, eval=TRUE}
library(UMI4Cats)
```

# Quick start
## Processing FASTQ files

```{r processing-quick-start, eval=FALSE}
## 1) Setup python virtual environment & dependencies -----
py_umi4cats <- "venv_UMI4Cats" 
installVenv(py_umi4cats)

## 2) Generate Digested genome ----------------------------
# The selected RE in this case is DpnII (|GATC), so the cs5p is "" and cs3p is GATC
hg19_dpnii <- digestGenome(cut_pos = 0,
                           res_enz = "GATC",
                           name_RE = "DpnII",
                           refgen = BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19, 
                           out_path = "digested_genome/")

## 3) Process UMI-4C fastq files --------------------------
raw_dir <- "path/to/fastq"

#TODO: hg19_dpnii Sshoud be the link of the digested genome file
contactsUMI4C(fastq_dir = raw_dir,
              wk_dir = "SOCS1",
              bait_seq = "CCCAAATCGCCCAGACCAG",
              bait_pad = "GCGCG",
              res_enz = "GATC",
              cut_pos = 0,
              digested_genome = hg19_dpnii,
              ref_gen = "/biodata/indices/species/Hsapiens/ucsc.hg19.fa",
              threads = 5)

``` 


## Analyzing UMI-4C results
```{r analysis-quick-start, eval=TRUE, fig.width=7, fig.height=5}
## Get filtering and alignment stats ---------
statsUMI4C(fastq_dir = raw_dir,
          wk_dir = system.file("extdata", "SOCS1",
                               package="UMI4Cats"))

# Load sample processed file paths
files <- list.files(system.file("extdata", "SOCS1", "rst", 
                                package="UMI4Cats"),
                    pattern="*10M.tsv",
                    full.names=TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub("_umi_counts_counts10M.tsv", "", basename(files)),
                      file = files,
                      stringsAsFactors=F)

library(tidyr)
colData <- colData %>% 
  separate(sampleID, 
           into=c("condition", "replicate", "viewpoint"),
           remove=FALSE)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData=colData,
                 viewpoint_name="SOCS1")

# Perform differential test
umi <- fisherUMI4C(umi)

# Plot results
plotUMI4C(umi, ylim=c(0,4))
```


# Experiment design

<!-- TODO: Explain how FastQ files should be organized for projects with different viewpoints -->

# Processing UMI-4C FASTQ files

## Installing python dependencies

UMI4Cats package requires some python dependencies and modules. For this reason, it is necessary to create a pyhton virtual environment with all the required modules. The required modules are defined in the `python/requirements.txt` files that is installed along the package. To facilitat this process, we include the function `installVenv()` function, which will install all necessary requirements in the given `path_venv`. 

```{r, eval=FALSE}
# Install and set up all python dependencies
installVenv(path_venv = "venv_UMI4Cats")
```

## Reference genome digestion

For the processing of the UMI-4C FastQ files it is necessary to construct a digested genome using the appropriate restriction enzyme. The `UMI4Cats` package includes the `digestGenome()` function to make this process as easy as possible. The function uses a `BSgenome` object^[More information on `BSgenome` package and objects can be found [here](https://bioconductor.org/packages/release/bioc/html/BSgenome.html))] as reference genome and given a cutting sequence for the description enzyme, digests the reference genome.

The cutting position is defined by `cut_pos` a zero-based numeric integrer indicating the nucleotide position where restriction enzyme cuts.

In the following table you can see two examples of the different cutting sequences for *DpnII*, *Csp6I* and *HindIII*.

Restriction enzyme | Restriction seq | cut_pos
-------------------|-----------------|---------
DpnII              | `|GATC`         | 0        
Csp6I              | `G|TAC`         | 1    
HindIII            | `A|AGCTT`       | 1       

For this example, we are using the hg19 `BSGenome` object and we are going to digest it using *DpnII*. 

```{r, eval=FALSE}
library(BSgenome.Hsapiens.UCSC.hg19)
refgen <- BSgenome.Hsapiens.UCSC.hg19
refgen <- refgen

hg19_dpnii <- digestGenome(res_enz = "GATC",
                           cut_pos = 0,
                           name_RE = "DpnII",
                           refgen = refgen, 
                           out_path = "digested_genome/")

hg19_dpnii
#> [1] "digested_genome/BSgenome.Hsapiens.UCSC.hg19_DpnII.tsv"
```

Additionally, the `digestGenome()` function returns invisibly the path of the generated file, so you can redirect it to a variable (in this case `hg19_dpnii`).

## Demultiplex FastQ files for different baits

UMI4Cats package provides a fastq-multx parser for demultiplexing paired-end FastQ files. Barcodes and bait names need to be provided as a data.frame as follows in the next example:

```{r, eval=FALSE}
barcodes <- data.frame(sample=c("KLK3", "KLK6", "KLK7", "KLK10"),
                      barcode=c("ATGGTCTGGGCGCTGTCTTG",
                                "TATTCTTCCTCAGCCCACATCTT",
                                "GGATGAAGATTTTGGAGCCCAGC",
                                "GGGCGGGGATTGAACGC"))

demultiplexFastq(barcodes=barcodes,
                fastq="~/samples/sample_1_R1.fastq.gz",
                type="paired",
                out_path="raw_fastq")
```

## UMI-4C FastQ files processing

This step converts paired-end reads in the FastQ files to UMI counts in the genome fragments generated using the restriction enzymes. The basic function for doing this analysis is `contactsUMI4C()` and should be ran in samples generated with the same viewpoint and restriction enzyme. 

The function will consider all FastQ files in the same folder `fastq_dir` to be part of the same experiment (viewpoint + restriction enzyme).

For every experiment analysis, user needs to define 3 different sequences:
- **Bait/viewpoint sequence** (`bait_seq`). This is the downstream primer sequence (DS primer) that matches the sequence of the queried bait.
- **Padding sequence** (`bait_pad`). The padding sequence corresponds to the nucleotides betweeen the DS primer end and the restriction enzyme site.
- **Restriction enzyme sequence** (`res_enz`). This sequence is the restriction sequence recognized by the selected restriction enzyme.

![](https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fnmeth.3922/MediaObjects/41592_2016_Article_BFnmeth3922_Fig1_HTML.jpg?as=webp)

Additionally, it is necessary to define the restiction enzyme cutting postion (`cut_pos`) in the restriction sequence which corresponds to the site where the restriction enzyme cuts the sequence. For example, for DpnII (`|GATC`) `cut_pos = 0` and for Csp6I (`G|TAC`) `cut_pos = 1`. The function will also need the path for the digested genome (`digested_genome`) generated with the function `digestGenome()`.

As `contactsUMI4C()` performs an alignment using [Bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml), you will also need to provide a reference genome in fasta format and the corresponding indexes generated with bowtie2^[See the [getting started section](http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#getting-started-with-bowtie-2-lambda-phage-example) on the Bowtie2 page for more information on how to generate the index for the reference genome.]. The `ref_gen` argument will take as input the path for the fasta file format and requires for the generated indexes for that fasta file to be in the same folder. 

Finally, you also need to provide the path for the UMI4Cats python virtual envrionment that you can create using the function `installVenv()` and the number of threads to use for the analysis.

```{r, eval=FALSE}
contactsUMI4C(fastq_dir = raw_dir,
              wk_dir = "SOCS1",
              bait_seq = "CCCAAATCGCCCAGACCAG",
              bait_pad = "GCGCG",
              res_enz = "GATC",
              cut_pos = 0,
              digested_genome = hg19_dpnii,
              ref_gen = "/biodata/indices/species/Hsapiens/ucsc.hg19.fa",
              threads = 5,
              path_venv = py_umi4cats)
```


`contactsUMI4C()` will run the following processes sequentially:

1. FastQ files preparation (`prepR`).
2. Split reads at restriction sequences (`splitR`).
3. Align split reads to the reference genome (`alignmentR`).
4. Algorithm for collapsing reads coming from same molecule (`umiCounterR`).
5. Return all fragment ends 10Mb around the viewpoint (`mergeUMICounter`).

Finally, the output (UMI-4C counts) is a tsv file saved in `wk_dir/rst`. This file will be the input for the data analysis in the following section.

## Quality control measures
Once the contact analysis has been ran, the statistics of the UMI-4C filtering, aligment and final number of UMIs can be generated from the raw FastQ files and working directory. 

This will generate a file called `wk_dir/rst/logs.tsv` containing all the statistics and a summary plot will then be produced. 

```{r, eval=TRUE, fig.width=7, fig.height=5}
statsUMI4C(fastq_dir = raw_dir,
           wk_dir = system.file("extdata", "SOCS1",
                                package="UMI4Cats"))
```

# Analyzing UMI-4C data

For this part of the analysis each bait should be analyzed separately. A different `UMI4C` object should be created for each analyzed bait.

## Construct the `UMI4C` object

The first step of the UMI-4C data analysis consists on loading the tables generated by the function `umi4CatsContacts` and use them to construct a `UMI4C`object. All these steps are perform automatically by the `makeUMI4C` functions. 

The `makeUMI4C` will need as imput a data frame (`colData`) containing all relevant experiment information that will be needed for analyzing the data later on. The mandatory columns that this data frame should have are:

1. `sampleID`: Unique identifier for the sample.
2. `replicate`: Replicate identifier or number.
3. `condition`: Condition for performing the diferential analysis. For example: "control" and "treatment", two different cell types, etc. The condition column should only have **two** different values. If more condition variables are provided, the differential analysis will fail.
4. `file`: Complete path and filename where the tsv files generated by `umi4CatsContacts` are saved.

You can also include additional columns to `colData`, but the ones mentioned above are mandatory.

Additionally, the `makeUMI4C` function also contains other arguments that can be used if you want to tweak the default parameters of the analysis. See `?makeUMI4C` to have a complete list and description of all the arguments.

```{r}
# Load sample processed file paths
files <- list.files(system.file("extdata", "SOCS1", "rst", 
                                package = "UMI4Cats"),
                    pattern = "*counts10M.tsv",
                    full.names = TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub("_umi_counts_counts10M.tsv", "", basename(files)),
                      file = files,
                      stringsAsFactors = FALSE)

library(tidyr)
colData <- colData %>% 
  separate(sampleID, 
           into = c("condition", "replicate", "viewpoint"),
           remove = FALSE)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData = colData,
                 viewpoint_name = "SOCS1")
```

This function contains several basic steps for preparing and analzying the UMI-4C data:

1. Removing fragment ends around the bait. The default value can be changed using the `bait_exclusion` argument.
2. Focusing the scope of the analysis in a specific region around the bait. The default value can be changed using the `bait_expansion` argument.
3. Obtaining the normalization matrices that will be used to scale the samples to the reference sample. If you want to avoid this normalization step, you can set `normalized` to `FALSE`.
4. Calculating the domainograms for each sample.
5. Calculating the adaptative trend for each sample.


## Perform differential analysis

### Plotting the `UMI4C` object

Once the `UMI4C` object is created, you can plot it using the `plotUMI4C` function. By default, the function will combine the samples using the **condition** column from `colData(umi)` (the colData data frame you provided for generating the `UMI4C` object), but you can change this behaviour using the `grouping` argument. You can give it one or several column names and will to the grouping based on those variables. For example, if you set `grouping="sampleID"` it will plot the individual profiles. You can group the data using several columns as well.

```{r}
plotUMI4C(umi)

plotUMI4C(umi, grouping = "sampleID")

plot(umi, grouping = c("replicate", "condition"))
```


