#' UMI4C Contacts Processing
#'
#' Using demultiplexed FastQ files as input, performs all necessary steps to end up with a tsv file summarizing the
#' restriction enzyme fragments and the number of UMIs supporting that specific contact with the viewpoint (bait) of
#' interest.
#'
#' @param fastq_dir Path of the directory containing the FastQ files (compressed or uncompressed).
#' @param wk_dir Working directory where to save the outputs generated by the UMI-4c analysis.
#' @param bait_seq Character containing the bait primer sequence.
#' @param bait_pad Character containing the pad sequence (sequence between the bait primer and the restriction enzyme sequence).
#' @param res_enz Character containing the restriction enzyme sequence.
#' @param cut_pos Numeric indicating the nucleotide position where restriction enzyme cuts (zero-based) (for example, for DpnII is 0).
#' @param digested_genome Path for the digested genome file generated using the \code{\link{digestGenome}} function.
#' @param ref_gen Path for the reference genome to use for the alignment (fasta format).
#' @param threads Number of threads to use in the analysis.
#' @param cut_seq_5p 5' restriction enzyme cut sequence. For example, for DpnII |GATC \code{cut_seq_5p=""}.
#' @param cut_seq_3p 3' restriction enzyme cut sequence. For example, for DpnII |GATC \code{cut_seq_3p="GATC"}.
#' @details This function is a combination of calls to other functions that perform the necessary steps for processing
#' UMI-4C data.
#' @examples
#' \dontrun{
#' contactsUMI4C(fastq_dir="raw_fastq",
#'               wk_dir="SOCS1",
#'               bait_seq="CCCAAATCGCCCAGACCAG",
#'               bait_pad="GCGCG",
#'               res_enz="GATC",
#'               cut_pos=0,
#'               digested_genome=hg19_dpnii,
#'               ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'               threads=1,
#'               path_venv="~/venvs/UMI4Cats_venv/",
#'               fastq_multx="fastq-multx")
#' }
#' @export
contactsUMI4C <- function(fastq_dir,
                          wk_dir,
                          bait_seq,
                          bait_pad,
                          res_enz,
                          cut_pos,
                          digested_genome,
                          ref_gen,
                          threads=1,
                          path_venv,
                          fastq_multx="fastq-multx"){

  dir.create(wk_dir, showWarnings=FALSE)
  cut_pos <- as.character(cut_pos) # convert to character

  prepUMI4C(fastq_dir = fastq_dir,
        wk_dir = wk_dir,
        bait_seq = bait_seq,
        bait_pad = bait_pad,
        res_enz = res_enz)

  splitUMI4C(wk_dir = wk_dir,
             cut_seq_5p = cut_seq_5p,
             cut_seq_3p = cut_seq_3p)

  alignmentR(path_venv = path_venv,
             wk_dir = wk_dir,
             threads = threads,
             ref_gen = ref_gen,
             bait_seq = bait_seq,
             bait_pad = bait_pad,
             res_enz = res_enz)

  umiCounterR(path_venv = path_venv,
              wk_dir = wk_dir,
              ref_gen = ref_gen,
              digested_genome = digested_genome,
              bait_seq = bait_seq,
              bait_pad = bait_pad,
              res_enz = res_enz)

  mergeUMICounter(digested_genome = digested_genome,
                  wk_dir = wk_dir,
                  bait_seq = bait_seq,
                  bait_pad = bait_pad,
                  res_enz = res_enz,
                  ref_gen = ref_gen)
}

#' Prepare UMI4C data
#'
#' Prepare the FastQ files for the analysis by selecting reads with bait and
#' adding the respective UMI identifier for each read in its header.
#' @inheritParams contactsUMI4C
#' @seealso \code{\link{contactsUMI4C}}
#' @examples
#' \dontrun{
#' prepUMI4C(fastq_dir="raw_fastq",
#'       wk_dir="SOCS1",
#'       bait_seq="CCCAAATCGCCCAGACCAG",
#'       bait_pad="GCGCG",
#'       res_enz="GATC")
#'}
#'
#'@export

prepUMI4C <- function(fastq_dir,
                      wk_dir,
                      bait_seq,
                      bait_pad,
                      res_enz){


  # create directory
  prep_dir <- file.path(wk_dir, 'prep')
  dir.create(prep_dir, showWarnings = F)

  # define variables
  fastq_files <- list.files(fastq_dir,
                            pattern = "\\.fastq$|\\.fq$|\\.gz$",
                            full.names = T)

  fastqR1_files <- fastq_files[grep("R1", fastq_files)]

  # define main function
  prep <- function(fastqR1_file){

    fastqR2_file <- gsub("R1", "R2", fastqR1_file)
    reads_fqR1 <- ShortRead::readFastq(fastqR1_file)
    reads_fqR2 <- ShortRead::readFastq(fastqR2_file)

    # insert umi identifier (10 first bp of R2) to header of both R1 R2 files

    # filter reads that not present bait seq + bait pad + re
    barcode <- paste0(bait_seq, bait_pad, res_enz)

    barcode_reads_fqR1 <- reads_fqR1[grepl(barcode, ShortRead::sread(reads_fqR1))]
    barcode_reads_fqR2 <- reads_fqR2[grepl(barcode, ShortRead::sread(reads_fqR1))]

    # add umi header
    umis <- stringr::str_sub(ShortRead::sread(barcode_reads_fqR2), -10)

    new_id_R1 <- paste0(ShortRead::id(barcode_reads_fqR1), " umi:", umis)
    new_id_R2 <- paste0(ShortRead::id(barcode_reads_fqR2), " umi:", umis)

    umi_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR1),
                                            Biostrings::quality(barcode_reads_fqR1),
                                            Biostrings::BStringSet(new_id_R1))

    umi_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR1),
                                            Biostrings::quality(barcode_reads_fqR1),
                                            Biostrings::BStringSet(new_id_R2))

    # filter reads with less than 20 phred score
    filter20phred <- lapply(as(Biostrings::PhredQuality(Biostrings::quality(umi_reads_fqR1)), 'IntegerList'), mean) >= 20 &
      lapply(as(Biostrings::PhredQuality(Biostrings::quality(umi_reads_fqR2)), 'IntegerList'), mean) >= 20

    filtered_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(umi_reads_fqR1)[filter20phred],
                                                 Biostrings::quality(umi_reads_fqR1)[filter20phred],
                                                 ShortRead::id(umi_reads_fqR1)[filter20phred])

    filtered_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(umi_reads_fqR2)[filter20phred],
                                                 Biostrings::quality(umi_reads_fqR2)[filter20phred],
                                                 ShortRead::id(umi_reads_fqR2)[filter20phred])

    # write output fastq files

    prep_fastqR1 <- paste0(gsub('\\..*', '', basename(fastqR1_file)), ".fq.gz")
    prep_fastqR2 <- paste0(gsub('\\..*', '', basename(fastqR2_file)), ".fq.gz")

    ShortRead::writeFastq(filtered_reads_fqR1, file.path(prep_dir, prep_fastqR1))
    ShortRead::writeFastq(filtered_reads_fqR2, file.path(prep_dir, prep_fastqR2))
  }

  # apply main function to files
  lapply(fastqR1_files, prep)

}

#' Split UMI4C reads
#'
#' Split the prepared reads using the restrition enzyme information.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' splitUMI4C(wk_dir="SOCS1",
#'        cut_seq_5p="",
#'        cut_seq_3p="GATC")
#' }
#' @export

splitUMI4C <- function(wk_dir,
                       prep_dir = "",
                       cut_seq_5p,
                       cut_seq_3p){

  # create directory
  prep_dir <- file.path(wk_dir, 'prep')
  split_dir <- file.path(wk_dir, 'split')

  dir.create(split_dir, showWarnings = F)

  # define variables
  re <- paste0(cut_seq_5p, cut_seq_3p)
  cp5p <- nchar(cut_seq_5p)
  cp3p <- nchar(cut_seq_3p)

  prep_files <- list.files(prep_dir,
                           pattern = ".gz$",
                           full.names = T)

  # define main function

  split <- function(prep_file){

    # define variables and create objects
    prep_reads <- ShortRead::readFastq(prep_file)
    prep_dna_string <- ShortRead::sread(prep_reads)

    list_id <- c()
    list_seq <- c()
    list_quals <- c()

    # split fastq by restriction enzyme
    for(fastq_line in seq(length(prep_dna_string))){

      # define restriction sites
      matches <- Biostrings::matchPattern(re, prep_dna_string[[fastq_line]])
      temp_df <- data.frame(start = start(GenomicRanges::gaps(matches)) - cp3p,
                            end = end(Biostrings::gaps(matches)) + cp5p) # add re nucleotide length
      temp_df$start[temp_df$start<0] <- 1

      list_id_tmp <- c()
      list_seq_tmp <- c()
      list_quals_tmp <- c()

      # split every seq and qa and join them
      for(pos in seq(nrow(temp_df))){

        id_tmp <- ShortRead::id(prep_reads)[fastq_line]

        seq_char <- as.character(prep_dna_string[[fastq_line]])
        seq_tmp <- substr(seq_char, start = temp_df$start[pos], stop = temp_df$end[pos])

        quals <- as.character(Biostrings::quality(Biostrings::quality(prep_reads))[fastq_line])
        qual_tmp <- substr(quals[1], start = temp_df$start[pos], stop = temp_df$end[pos])

        list_id_tmp <- append(list_id_tmp, id_tmp)
        list_seq_tmp <- c(list_seq_tmp, seq_tmp)
        list_quals_tmp <- c(list_quals_tmp, qual_tmp)

      }


      list_id <- append(list_id, list_id_tmp)
      list_seq <- c(list_seq, list_seq_tmp)
      list_quals <- c(list_quals, list_quals_tmp)

    }

    # generate splited fastq file
    list_seq <- Biostrings::DNAStringSet(list_seq)
    list_quals <- ShortRead::FastqQuality(list_quals)

    fastq_file <- ShortRead::ShortReadQ(list_seq,
                                        list_quals,
                                        list_id)

    splited_fastq_name <- paste0(gsub("\\..*$", basename(prep_file)), ".fq.gz")

    splited_fastq <- file.path(split_dir, splited_fastq_name)

    ShortRead::writeFastq(fastq_file, splited_fastq)
  }


  # run main function
  lapply(prep_files, split)
}


#' UMI4C alignment
#'
#' Align splitted UMI-4C reads to a reference genome using Bowtie2.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' alignmentR(wk_dir="SOCS1",
#'            bait_seq="CCCAAATCGCCCAGACCAG",
#'            bait_pad="GCGCG",
#'            res_enz="GATC",
#'            ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'            threads=1,
#'            path_venv="~/venvs/UMI4Cats_venv/")
#' }
#'
#' @export
library(Rbowtie2)
library(Rsamtools)
parallel
library(R.utils)

alignmentR <- function(wk_dir,
                       bait_seq,
                       bait_pad,
                       res_enz,
                       ref_gen,
                       threads=1,
                       ){


  # get coordinates of viewpoint using bowtie2
  viewpoint <-  paste0(bait_seq, bait_pad, res_enz)

  # TODO: bowtie index autogeneration if not exist? set automatic bowtie or define path?
  bowtie_index <- gsub('\\..*$', '', ref_gen)

  bowtie_build(references = ref_gen,
               outdir = dirname(ref_gen),
               prefix = gsub('\\..*$', '', basename(ref_gen)),
               force=TRUE)

  # TODO: bsgenome and Biostrings::matchPattern(re, refgen[[chr]])
  view_point_pos <- system(paste(system.file(package="Rbowtie2", "bowtie2-align-s"),
                                 '--quiet',
                                 '-N 0',
                                 '-x', bowtie_index,
                                 '-c', viewpoint),
                           intern = T)


  view_point_pos <- tail(view_point_pos, n = 1)
  view_point_pos <- unlist(strsplit(view_point_pos, "\t"))

  pos_chr <- view_point_pos[3]
  pos_start <- as.numeric(view_point_pos[4])
  pos_end <- pos_start + nchar(viewpoint)

  # align splited files
  split_dir <- file.path(wk_dir, 'split')
  split_dir = '/imppc/labs/lplab/share/marc/epimutations/raw/fastq/umi4c/prove/wk_dir/prep'

  splited_files <- list.files(split_dir,
                              pattern = ".gz$",
                              full.names = T)


  for(splited_file in splited_files){
    sam <-  paste0(gsub("\\..*$", "", splited_file), ".sam")
    bam <-  paste0(gsub("\\..*$", "", splited_file), ".bam")
    filtered_bam <-  paste0(gsub("\\..*$", "", splited_file), "_filtered.bam")
    log <-  paste0(gsub("\\..*$", "", splited_file), ".log")

    R.utils::gunzip(splited_file)

    splited_file <-  gsub('\\.gz', '', splited_file)

    Rbowtie2::bowtie2(seq1 = splited_file,
                      seq2 = NULL,
                      bt2Index = bowtie_index,
                      "--threads", parallel::detectCores(),
                      samOutput = sam)

    bam_object <- Rsamtools::scanBam(bam)
    bam_object <- as.data.frame(bam_object)
    bam_object_filtered <- bam_object[bam_object$mapq >= 42,]
    bam_object_filtered <- as.list(bam_object_filtered)
    out = '/imppc/labs/lplab/share/marc/epimutations/raw/fastq/umi4c/prove/wk_dir/prep/filtered.bam'
    filterBam(file = bam_object_filtered, destination = out)
    save(bam_object_filtered, file = out, bam_object_filtered)
    Rsamtools::scanBam(bam_object_filtered)


    ###########

    # sam to bam
    Rsamtools::asBam(sam)

    # only chrom where the view point is present and mapq of 42 at least
    filter_mapq <- FilterRules(list(mapq_filter = function(x) x$mapq >= 42))
    filterBam(bam, filtered_bam, filter = filter_mapq, param=ScanBamParam(what="mapq"))

  # without header for being able to load in pandas

  cmd = 'samtools view {bam} -@ {threads} -q 42 {chrVP} > {samFiltered}'.format(threads = threads,
                                                                                bam = bam,
                                                                                chrVP = chrVP,
                                                                                samFiltered = samFiltered)
}

#' UMI counting
#'
#' Algorithm for counting  and collapsing the number of UMIs supporting a specific ligation.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' umiCounterR(wk_dir="SOCS1",
#'             bait_seq="CCCAAATCGCCCAGACCAG",
#'             bait_pad="GCGCG",
#'             res_enz="GATC",
#'             digested_genome=hg19_dpnii,
#'             ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'             path_venv="~/venvs/UMI4Cats_venv/")
#' }
#' @details For collapsing different molecules into the same UMI, takes into account the ligation position and
#' the number of UMI sequence mismatches.
#' @export

umiCounterR <- function(wk_dir,
                        bait_seq,
                        bait_pad,
                        res_enz,
                        digested_genome,
                        ref_gen,
                        path_venv){

  reticulate::use_virtualenv(path_venv, required = TRUE)
  py_functions <- system.file("python/umi4cats.py", package = "UMI4Cats")
  reticulate::source_python(py_functions)

  bowtie2 <- "bowtie"
  samtools <- "samtools"

  umiCounter(wk_dir = wk_dir,
             bowtie2 = bowtie2,
             ref_gen = ref_gen,
             samtools = samtools,
             genomic_track = digested_genome,
             bait_seq = bait_seq,
             bait_pad = bait_pad,
             res_e = res_enz)

}


#' Merge UMI4C counts
#'
#' Merge UMI4C counts with digested genome framgment position, returning all fragments and UMIs
#' 10Mb around the viewpoint.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' mergeUMICounter(wk_dir="SOCS1",
#'                 digested_genome=hg19_dpnii,
#'                 bait_seq="CCCAAATCGCCCAGACCAG",
#'                 bait_pad="GCGCG",
#'                 res_enz="GATC",
#'                 ref_gen="~/data/reference_genomes/hg19/hg19.fa")
#' }
#' @export
mergeUMICounter <- function(digested_genome,
                            wk_dir,
                            bait_seq,
                            bait_pad,
                            res_enz,
                            ref_gen){

  bowtie2 <- 'bowtie2'

  counts_path <- file.path(wk_dir, 'rst')

  umi_files <- list.files(counts_path,
                          full.names = T,
                          pattern = '\\_umi_counts.tsv$')


  counts_path <- file.path(wk_dir, 'rst')

  for(umis in umi_files){

    file_name <- gsub("\\..*$", "", basename(umis))

    df_umis <- read.table(umis)

    df_umis <- data.frame(lapply(df_umis, as.character), stringsAsFactors=FALSE)

    colnames(df_umis) <- c('chr_bait', 'pos_bait', 'chr_contact', 'pos_contact', 'UMIs')

    df_dig_genome <- read.table(digested_genome, stringsAsFactors = F)

    # get coordinates of viewpoint using bowtie2
    viewpoint <- paste0(bait_seq, bait_pad, res_enz)

    index <- gsub('\\..*$', '', ref_gen)

    viewpointPos <- system(paste("bowtie2 --quiet",
                                 "-x", index,
                                 "-c", viewpoint,
                                 "-N 0",
                                 "| samtools view",
                                 "| awk \'{print $3,$4}\'"),
                           intern = T)

    viewpointPos <- unlist(strsplit(viewpointPos, " "))
    chrVP <- viewpointPos[1]
    startVP <- as.numeric(viewpointPos[2])

    start10M <- startVP - 10e6
    end10M <- startVP + 10e6

    sub_df_dig_genome <- df_dig_genome[(df_dig_genome$V1 == chrVP) &
                                         (df_dig_genome$V2 >= start10M) &
                                         (df_dig_genome$V2 <= end10M),]

    sub_df_dig_genome <- sub_df_dig_genome[c(1,2)]

    colnames(sub_df_dig_genome)[1:2] <- c('chr_contact', 'pos_contact')

    sub_df_dig_genome <- data.frame(lapply(sub_df_dig_genome, as.character), stringsAsFactors=FALSE)

    df_umi_10M <- dplyr::left_join(sub_df_dig_genome, df_umis)
    df_umi_10M$UMIs[is.na(df_umi_10M$UMIs)] <- 0
    df_umi_10M$chr_bait[is.na(df_umi_10M$chr_bait)] <- unique(df_umis$chr_bait)
    df_umi_10M$pos_bait[is.na(df_umi_10M$pos_bait)] <- unique(df_umis$pos_bait)


    df_umi_10M <- df_umi_10M[,c('chr_bait', 'pos_bait', 'chr_contact', 'pos_contact', 'UMIs')]

    umi_output <- file.path(wk_dir, 'rst', paste0(file_name, '_counts10M.tsv'))

    write.table(x = df_umi_10M,
                file = umi_output,
                row.names = F,
                quote = F,
                sep = '\t')
  }
}

