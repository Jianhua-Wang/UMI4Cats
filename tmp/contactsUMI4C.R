#' UMI4C Contacts Processing
#'
#' Using demultiplexed FastQ files as input, performs all necessary steps to end up with a tsv file summarizing the
#' restriction enzyme fragments and the number of UMIs supporting that specific contact with the viewpoint (bait) of
#' interest.
#'
#' @param fastq_dir Path of the directory containing the FastQ files (compressed or uncompressed).
#' @param wk_dir Working directory where to save the outputs generated by the UMI-4c analysis.
#' @param bait_seq Character containing the bait primer sequence.
#' @param bait_pad Character containing the pad sequence (sequence between the bait primer and the restriction enzyme sequence).
#' @param res_enz Character containing the restriction enzyme sequence.
#' @param cut_pos Numeric indicating the nucleotide position where restriction enzyme cuts (zero-based) (for example, for DpnII is 0).
#' @param digested_genome Path for the digested genome file generated using the \code{\link{digestGenome}} function.
#' @param ref_gen Path for the reference genome to use for the alignment (fasta format).
#' @param threads Number of threads to use in the analysis.
#' @details This function is a combination of calls to other functions that perform the necessary steps for processing
#' UMI-4C data.
#' @examples
#' \dontrun{
#' contactsUMI4C(fastq_dir="raw_fastq",
#'               wk_dir="SOCS1",
#'               bait_seq="CCCAAATCGCCCAGACCAG",
#'               bait_pad="GCGCG",
#'               res_enz="GATC",
#'               cut_pos=0,
#'               digested_genome=hg19_dpnii,
#'               ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'               threads=1,
#'               path_venv="~/venvs/UMI4Cats_venv/",
#'               fastq_multx="fastq-multx")
#' }
#' @export
contactsUMI4C <- function(fastq_dir,
                          wk_dir,
                          bait_seq,
                          bait_pad,
                          res_enz,
                          cut_pos,
                          digested_genome,
                          ref_gen,
                          threads=1,
                          path_venv,
                          fastq_multx="fastq-multx"){

  dir.create(wk_dir, showWarnings=FALSE)
  cut_pos <- as.character(cut_pos) # convert to character

  prepUMI4C(fastq_dir = fastq_dir,
        wk_dir = wk_dir,
        bait_seq = bait_seq,
        bait_pad = bait_pad,
        res_enz = res_enz)

  splitR(path_venv = path_venv,
         wk_dir = wk_dir,
         res_enz = res_enz,
         cut_pos = cut_pos)

  alignmentR(path_venv = path_venv,
             wk_dir = wk_dir,
             threads = threads,
             ref_gen = ref_gen,
             bait_seq = bait_seq,
             bait_pad = bait_pad,
             res_enz = res_enz)

  umiCounterR(path_venv = path_venv,
              wk_dir = wk_dir,
              ref_gen = ref_gen,
              digested_genome = digested_genome,
              bait_seq = bait_seq,
              bait_pad = bait_pad,
              res_enz = res_enz)

  mergeUMICounter(digested_genome = digested_genome,
                  wk_dir = wk_dir,
                  bait_seq = bait_seq,
                  bait_pad = bait_pad,
                  res_enz = res_enz,
                  ref_gen = ref_gen)
}

#' Prepare UMI4C data
#'
#' Prepare the FastQ files for the analysis by selecting reads with bait and
#' adding the respective UMI identifier for each read in its header.
#' @inheritParams contactsUMI4C
#' @seealso \code{\link{contactsUMI4C}}
#' @examples
#' \dontrun{
#' prepUMI4C(fastq_dir="raw_fastq",
#'       wk_dir="SOCS1",
#'       bait_seq="CCCAAATCGCCCAGACCAG",
#'       bait_pad="GCGCG",
#'       res_enz="GATC")
#'}
#'
#'@export

prepUMI4C <- function(fastq_dir,
                      wk_dir,
                      bait_seq,
                      bait_pad,
                      res_enz){


  # create directory
  prep_dir <- file.path(wk_dir, 'prep')
  dir.create(prep_dir, showWarnings = F)

  # define variables
  fastq_files <- list.files(fastq_dir,
                            pattern = "\\.fastq$|\\.fq$|\\.gz$",
                            full.names = T)

  fastqR1_files <- fastq_files[grep("R1", fastq_files)]

  # define main function
  prep <- function(fastqR1_file){

    fastqR2_file <- gsub("R1", "R2", fastqR1_file)
    reads_fqR1 <- ShortRead::readFastq(fastqR1_file)
    reads_fqR2 <- ShortRead::readFastq(fastqR2_file)

    # insert umi identifier (10 first bp of R2) to header of both R1 R2 files

    # filter reads that not present bait seq + bait pad + re
    barcode <- paste0(bait_seq, bait_pad, res_enz)

    barcode_reads_fqR1 <- reads_fqR1[grepl(barcode, ShortRead::sread(reads_fqR1))]
    barcode_reads_fqR2 <- reads_fqR2[grepl(barcode, ShortRead::sread(reads_fqR1))]

    # add umi header
    umis <- stringr::str_sub(ShortRead::sread(barcode_reads_fqR2), -10)

    new_id_R1 <- paste0(ShortRead::id(barcode_reads_fqR1), " umi:", umis)
    new_id_R2 <- paste0(ShortRead::id(barcode_reads_fqR2), " umi:", umis)

    umi_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR1),
                                            Biostrings::quality(barcode_reads_fqR1),
                                            Biostrings::BStringSet(new_id_R1))

    umi_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR1),
                                            Biostrings::quality(barcode_reads_fqR1),
                                            Biostrings::BStringSet(new_id_R2))

    # filter reads with less than 20 phred score
    filter20phred <- lapply(as(Biostrings::PhredQuality(Biostrings::quality(umi_reads_fqR1)), 'IntegerList'), mean) >= 20 &
      lapply(as(Biostrings::PhredQuality(Biostrings::quality(umi_reads_fqR2)), 'IntegerList'), mean) >= 20

    filtered_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(umi_reads_fqR1)[filter20phred],
                                                 Biostrings::quality(umi_reads_fqR1)[filter20phred],
                                                 ShortRead::id(umi_reads_fqR1)[filter20phred])

    filtered_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(umi_reads_fqR2)[filter20phred],
                                                 Biostrings::quality(umi_reads_fqR2)[filter20phred],
                                                 ShortRead::id(umi_reads_fqR2)[filter20phred])

    # write output fastq files

    prep_fastqR1 <- paste0(gsub('\\..*', '', basename(fastqR1_file)), ".fq.gz")
    prep_fastqR2 <- paste0(gsub('\\..*', '', basename(fastqR2_file)), ".fq.gz")

    ShortRead::writeFastq(filtered_reads_fqR1, file.path(prep_dir, prep_fastqR1))
    ShortRead::writeFastq(filtered_reads_fqR2, file.path(prep_dir, prep_fastqR2))
  }

  # apply main function to files
  lapply(fastqR1_files, prep)

}

#' Split UMI4C reads
#'
#' Split the prepared reads using the restrition enzyme information.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' splitR(wk_dir="SOCS1",
#'        res_enz="GATC",
#'        cut_pos=0,
#'        path_venv="~/venvs/UMI4Cats_venv/")
#' }
#' @export

splitR <- function(wk_dir,
                   res_enz,
                   cut_pos,
                   path_venv){}


cut_seq_5p=""
cut_seq_3p="GATC"
name_RE="DpnII"
out_path="digested_genome/"

prep_dir <- file.path(wk_dir, 'prep')

prep_files <- list.files(prep_dir,
                         pattern = ".gz$",
                         full.names = T)


re <- paste0(cut_seq_5p, cut_seq_3p)
cp5p <- nchar(cut_seq_5p)
cp3p <- nchar(cut_seq_3p)

prep_file <- '/imppc/labs/lplab/share/marc/epimutations/raw/fastq/umi4c/prove/wk_dir/prep/prove.fq'

matches <- Biostrings::matchPattern(re, prep_dna_string[[i]])

DNAStringSet(matches)




Views(prep_dna_string[[i]], Biostrings::gaps(matches))




prep_reads <- ShortRead::readFastq(prep_file)

lapply(seq(1:nrow(temp_df)), tmpFunc)

tmpFunc <- function(i){
  cat(as.character(id(prep_reads[1])))
  cat(substr(as.character(quality(prep_reads[1])[[1]]), temp_df$start[i], temp_df$end[i]))
  cat(paste('+'))
  cat(substr(as.character(sread(prep_reads[1])), temp_df$start[i], temp_df$end[i]))
}



prep_dna_string <- sread(prep_reads)
i = 1
j = 1

matches <- Biostrings::matchPattern(re, prep_dna_string[[i]])

temp_df <- data.frame(start = start(GenomicRanges::gaps(matches)) - cp3p,
                      end = end(Biostrings::gaps(matches)) + cp5p) # add re nucleotide length

temp_df$start[temp_df$start<0] <- 1

DNAStringSet(prep_dna_string[i], start = temp_df$start[j], end = temp_df$end[j])

Biostrings::quality(prep_reads)[i]
DNAStringSet(Biostrings::quality(prep_reads)[i], start = temp_df$start[j], end = temp_df$end[j])


ShortRead::id(umi_reads_fqR2)[filter20phred])

genome_track <- rbind(genome_track,
                      temp_df)
}

# Save digested genome
dir.create(out_path, showWarnings = FALSE) # Create directory if it doesn't exist
out_track <- file.path(out_path, paste0(GenomeInfoDb::bsgenomeName(refgen), "_", name_RE, '.tsv'))

write.table(genome_track,
          out_track,
          col.names = FALSE,
          row.names = FALSE,
          quote = FALSE,
          sep = "\t")



#' UMI4C alignment
#'
#' Align splitted UMI-4C reads to a reference genome using Bowtie2.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' alignmentR(wk_dir="SOCS1",
#'            bait_seq="CCCAAATCGCCCAGACCAG",
#'            bait_pad="GCGCG",
#'            res_enz="GATC",
#'            ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'            threads=1,
#'            path_venv="~/venvs/UMI4Cats_venv/")
#' }
#'
#' @export

alignmentR <- function(wk_dir,
                       bait_seq,
                       bait_pad,
                       res_enz,
                       ref_gen,
                       threads=1,
                       path_venv){

  reticulate::use_virtualenv(path_venv, required = TRUE)
  py_functions <- system.file("python/umi4cats.py", package = "UMI4Cats")
  reticulate::source_python(py_functions)

  # TODO: Move to {Rbowtie2} and {Rsamtools}
  bowtie2 <- "bowtie2"
  samtools <- "samtools"

  alignment(wk_dir = wk_dir,
            threads = threads,
            bowtie2 = bowtie2,
            ref_gen = ref_gen,
            samtools = samtools,
            bait_seq = bait_seq,
            bait_pad = bait_pad,
            res_e = res_enz)

}

#' UMI counting
#'
#' Algorithm for counting  and collapsing the number of UMIs supporting a specific ligation.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' umiCounterR(wk_dir="SOCS1",
#'             bait_seq="CCCAAATCGCCCAGACCAG",
#'             bait_pad="GCGCG",
#'             res_enz="GATC",
#'             digested_genome=hg19_dpnii,
#'             ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'             path_venv="~/venvs/UMI4Cats_venv/")
#' }
#' @details For collapsing different molecules into the same UMI, takes into account the ligation position and
#' the number of UMI sequence mismatches.
#' @export

umiCounterR <- function(wk_dir,
                        bait_seq,
                        bait_pad,
                        res_enz,
                        digested_genome,
                        ref_gen,
                        path_venv){

  reticulate::use_virtualenv(path_venv, required = TRUE)
  py_functions <- system.file("python/umi4cats.py", package = "UMI4Cats")
  reticulate::source_python(py_functions)

  bowtie2 <- "bowtie"
  samtools <- "samtools"

  umiCounter(wk_dir = wk_dir,
             bowtie2 = bowtie2,
             ref_gen = ref_gen,
             samtools = samtools,
             genomic_track = digested_genome,
             bait_seq = bait_seq,
             bait_pad = bait_pad,
             res_e = res_enz)

}


#' Merge UMI4C counts
#'
#' Merge UMI4C counts with digested genome framgment position, returning all fragments and UMIs
#' 10Mb around the viewpoint.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' mergeUMICounter(wk_dir="SOCS1",
#'                 digested_genome=hg19_dpnii,
#'                 bait_seq="CCCAAATCGCCCAGACCAG",
#'                 bait_pad="GCGCG",
#'                 res_enz="GATC",
#'                 ref_gen="~/data/reference_genomes/hg19/hg19.fa")
#' }
#' @export
mergeUMICounter <- function(digested_genome,
                            wk_dir,
                            bait_seq,
                            bait_pad,
                            res_enz,
                            ref_gen){

  bowtie2 <- 'bowtie2'

  counts_path <- file.path(wk_dir, 'rst')

  umi_files <- list.files(counts_path,
                          full.names = T,
                          pattern = '\\_umi_counts.tsv$')


  counts_path <- file.path(wk_dir, 'rst')

  for(umis in umi_files){

    file_name <- gsub("\\..*$", "", basename(umis))

    df_umis <- read.table(umis)

    df_umis <- data.frame(lapply(df_umis, as.character), stringsAsFactors=FALSE)

    colnames(df_umis) <- c('chr_bait', 'pos_bait', 'chr_contact', 'pos_contact', 'UMIs')

    df_dig_genome <- read.table(digested_genome, stringsAsFactors = F)

    # get coordinates of viewpoint using bowtie2
    viewpoint <- paste0(bait_seq, bait_pad, res_enz)

    index <- gsub('\\..*$', '', ref_gen)

    viewpointPos <- system(paste("bowtie2 --quiet",
                                 "-x", index,
                                 "-c", viewpoint,
                                 "-N 0",
                                 "| samtools view",
                                 "| awk \'{print $3,$4}\'"),
                           intern = T)

    viewpointPos <- unlist(strsplit(viewpointPos, " "))
    chrVP <- viewpointPos[1]
    startVP <- as.numeric(viewpointPos[2])

    start10M <- startVP - 10e6
    end10M <- startVP + 10e6

    sub_df_dig_genome <- df_dig_genome[(df_dig_genome$V1 == chrVP) &
                                         (df_dig_genome$V2 >= start10M) &
                                         (df_dig_genome$V2 <= end10M),]

    sub_df_dig_genome <- sub_df_dig_genome[c(1,2)]

    colnames(sub_df_dig_genome)[1:2] <- c('chr_contact', 'pos_contact')

    sub_df_dig_genome <- data.frame(lapply(sub_df_dig_genome, as.character), stringsAsFactors=FALSE)

    df_umi_10M <- dplyr::left_join(sub_df_dig_genome, df_umis)
    df_umi_10M$UMIs[is.na(df_umi_10M$UMIs)] <- 0
    df_umi_10M$chr_bait[is.na(df_umi_10M$chr_bait)] <- unique(df_umis$chr_bait)
    df_umi_10M$pos_bait[is.na(df_umi_10M$pos_bait)] <- unique(df_umis$pos_bait)


    df_umi_10M <- df_umi_10M[,c('chr_bait', 'pos_bait', 'chr_contact', 'pos_contact', 'UMIs')]

    umi_output <- file.path(wk_dir, 'rst', paste0(file_name, '_counts10M.tsv'))

    write.table(x = df_umi_10M,
                file = umi_output,
                row.names = F,
                quote = F,
                sep = '\t')
  }
}

