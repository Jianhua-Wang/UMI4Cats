#' Differential UMI4C contacts using Fisher's Exact test
#'
#' Using the UMIs inside \code{query_regions} performs Fisher's Exact test to calculate significant differences
#' between contact intensities.
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the \code{UMI4C} constructor.
#' @param grouping Name of the \code{colData(UMI4C)} column that will be used for grouping the UMI4C profiles
#' and performing differential analyses.
#' @param query_regions \code{GenomicRanges} object containing the coordinates for the regions where to
#' perform the differential analysis.
#' @param resize Width in base pairs for resizing the query regions. Default: no resizing.
#' @param padj_method Method for adjusting p-values. See \code{\link[stats]{p.adjust}} for the different methods.
#' @details In order to calculate differential contact intensities, this fuction first sums all UMIs for each
#' grouping condition. Then, calculates the overlap of fragment ends with \code{query_regions}. The resulting number
#' of UMIs in each \code{query_region} will be the sum of UMIs in all overlapping fragment ends. Then, a contingency
#' table for each \code{query_reegions} is created as follows:
#' \tabular{rcc}{
#'      \tab \emph{query_region} \tab \emph{region}\cr
#'     \emph{Reference} \tab n1 \tab N1-n1\cr
#'     \emph{Condition} \tab n2 \tab N2-n2
#'     }
#' and the Fisher's Exact test is performed.
#' @export
fisherUMI4C <- function(umi4c,
                        grouping="condition",
                        query_regions,
                        resize=NULL,
                        padj_method="fdr") {
  factor <- unique(colData(umi4c)[, grouping])

  if (length(factor)!=2) stop("Incorrect 'grouping' variable, it should divide your data in two groups.")

  ids_ref <- colData(umi4c)$sampleID[grep(factor[1], colData(umi4c)[,grouping])]
  ids_cond <- colData(umi4c)$sampleID[grep(factor[2], colData(umi4c)[,grouping])]

  row_ranges <- rowRanges(umi4c)
  umis <- assays(umi4c)$umis

  row_ranges$umis_ref <- rowSums(umis[,ids_ref, drop=FALSE])
  row_ranges$umis_cond <-  rowSums(umis[,ids_cond, drop=FALSE])

  total_ref <- sum(row_ranges$umis_ref, na.rm=TRUE)
  total_cond <- sum(row_ranges$umis_cond, na.rm=TRUE)

  # Resize query regions if value provided
  if(!is.null(resize)) query_regions <- GenomicRanges::resize(query_regions,
                                                              width=resize,
                                                              fix="center")

  # Find overlaps between fragment ends and query regions
  ols <- GenomicRanges::findOverlaps(row_ranges, query_regions)

  # Sum UMIs
  fends_split <- split(mcols(row_ranges)[queryHits(ols),], query_regions$id[subjectHits(ols)])
  fends_summary <- lapply(fends_split,
                          function(x) data.frame(umis_ref=sum(x$umis_ref, na.rm=TRUE),
                                                 umis_cond=sum(x$umis_cond, na.rm=TRUE)))
  fends_summary <- do.call(rbind, fends_summary)
  fends_summary$query_id <- names(fends_split)

  # TODO: in original paper they subtract mols in interval from total mols
  mat_list <- lapply(1:nrow(fends_summary), function(x) matrix(c(as.vector(t(fends_summary[x,1:2])),
                                                                 total_ref-fends_summary[x,1],
                                                                 total_cond-fends_summary[x,2]),
                                                               ncol=2,
                                                               dimnames=list(c("ref", "cond"),
                                                                             c("query", "region"))))

  fends_summary$pval <- unlist(lapply(mat_list, function(x) fisher.test(x)$p.value))
  fends_summary$odds_ratio <- unlist(lapply(mat_list, function(x) fisher.test(x)$estimate))
  fends_summary$padj <- p.adjust(fends_summary$pval, method=padj_method)

  return(fends_summary)
}

#' Differential UMI4C contacts using Fisher's Exact test
#'
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the \code{UMI4C} constructor.
#' @param design A \code{formula} or \code{matrix}. The formula expresses how the counts for
#' each fragment end depend on the variables in \code{colData}. See  \code{\link[DESeq2]{DESeqDataSet}}
#' @param normalized Logical indicating if the function shoult return normalized or raw UMI counts.
#' @param padj_method The method to use for adjusting p-values, see \code{\link[stats]{p.adjust}}
#' @param ... Other arguments to be passed to \code{\link[DESeq2]{DESeq}} function.
#' @export
deseq2UMI4c <- function(umi4c,
                        design= ~ condition,
                        normalized=TRUE,
                        padj_method="fdr",
                        ...) {
  dds <- DESeq2::DESeqDataSetFromMatrix(countData=assays(umi4c)$umis,
                                        colData=colData(umi4c),
                                        design=design)
  dds <- DESeq2::DESeq(dds,
                       ...)

  res <- DESeq2::results(dds,
                         pAdjustMethod=padj_method)

  res <- data.frame(res[,c(5,2,6)])
  res$contact_id <- rownames(res)

  counts <- counts(dds, normalized=normalized)
  res <- cbind(counts, res)

  return(res)
}
