#' Call significant interactions
#' 
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the
#' \code{UMI4C} constructor.
#' @param design A \code{formula} or \code{matrix}. The formula expresses how
#' the counts for each fragment end depend on the variables in \code{colData}.
#' See  \code{\link[DESeq2]{DESeqDataSet}}.
#' @param query_regions \code{GRanges} object or \code{data.frame} containing
#' the coordinates of the genomic regions you want to use to perform the
#' analysis in specific genomic intervals. Default: NULL.
#' @return \code{\link[GenomicRanges]{GRangesList}} where each element is a 
#' UMI4C sample with the queried regions and their adjusted p-values and Z-scores.
#' @export
callInteractions <- function(umi4c,
                             design=~condition,
                             query_regions) {
  ## Sum raw UMIs in query_regions
  umi_win_frags <- combineUMI4C(umi4c, query_regions)
  
  ## Convert to dds
  dds <- UMI4C2dds(umi4c = umi_win_frags, design = design)
  
  ## Perform variance stabilizing transformation
  dds <- vstUMI4C(dds = dds)
  
  ## Smooth monotone fit
  dds <- UMI4Cats:::smoothMonotoneUMI4C(dds = dds)
  
  ## Obtain z-scores
  dds <- zscoreUMI4C(dds)
  dds <- addPeaksUMI4C(dds, fdr_thresh=0.01)
}

#' Variance stabilizing transformation
#' 
#' Using a DDS object performs a variance stabilizing transformation from DESeq2 
#' package to the UMI4C counts
#' @param dds DDS object generated by \code{UMI4C2dds} 
#' @return DDS object with variance stabilizing transformation counts
#' @details This function estimate the size factors and dispersions of the counts
#' base on \code{\link[DESeq2]{DESeq}} for infering the VST distribution and
#' transform raw UMI4C counts.
vstUMI4C <- function(dds){
  if (!c("counts") %in% names(assays(dds))) 
    stop("No assay 'counts' found. Check your input.")
  
  message(paste(
    paste0("\n[", Sys.time(), "]"),
    "Starting vstUMI4C\n",
    "> Samples of DDS object:\n", paste(colnames(dds), sep="", collapse=", "), "\n"
  ))
  
  # vst transformation
  trafo <- assay(DESeq2::varianceStabilizingTransformation(dds, fitType='local'))
  assays(dds)[['trafo']] <- trafo
  
  message(
    paste0("[", Sys.time(), "] "),
    "Finished vstUMI4C"
  )
  
  return(dds)
}
#' Monotone smoothing of the DDS object VST counts
#' 
#' Takes the variance stabilized count values and calculates a symmetric
#' monotone fit for the distance dependency. The signal trend is fitted using 
#' the \href{https://CRAN.R-project.org/package=fda}{fda} package. The position 
#' information about the viewpoint have to be stored in the metadata as 
#' \code{metadata(dds)[['bait']]}.
#' @param dds DDS object as generated by \code{vstUMI4C} with the 
#' variance stabilized count values
#' @return DDS object with monotone smoothed fit counts. 
#' @details This function computes the smoothing function for the VST values, based on
#' \href{https://CRAN.R-project.org/package=fda}{fda} package, and calculates a symmetric monotone fit counts for the distance dependency
#' @inheritParams differentialNbinomWaldTestUMI4C
smoothMonotoneUMI4C <- function(dds,
                                alpha=20,
                                penalty=0.1){
  if (!c("trafo") %in% names(assays(dds))) 
    stop("No assay 'trafo' found. Check your input.")
  
  if (length(metadata(dds)[['bait']]) != 1) 
    stop("None or more than one viewpoint are contained in the dds object. Check your input.")
  
  message(paste(
    paste0("\n[", Sys.time(), "]"),
    "Starting smoothMonotoneUMI4C using:\n",
    "> Samples of DDS object:\n", paste(colnames(dds), sep="", collapse=", "), "\n",
    "> Alpha:\n", alpha,"\n",
    "> Penalty:\n", penalty,"\n"
  ))
  
  # calculate mid of the viewpoint
  frag_viewpoint <- metadata(dds)[['bait']]
  frag_viewpoint$mid = start(frag_viewpoint) + (end(frag_viewpoint) - start(frag_viewpoint))%/%2
  
  # calculate mid of frag coord
  frag_data <- rowRanges(dds)
  mcols(frag_data, level="within")$mid <- start(frag_data) + (end(frag_data) - start(frag_data))%/%2
  mcols(frag_data, level="within")$dist <- mid(frag_data) - mid(frag_viewpoint)
  mcols(frag_data, level="within")$log_dist <- log(abs(mcols(frag_data)[['dist']]))
  frag_data = as.data.frame(frag_data)
  
  # calculate smooth monotone fit and fit counts
  fit <- apply(assays(dds)[['trafo']], 2, .smoothMonotone, alpha,
               penalty,frag_data)
  
  fit <- as.data.frame(fit)
  
  row.names(fit) <- unlist(dimnames(dds)[1])
  
  assays(dds)[['fit']] <- fit
  
  message(
    paste0("[", Sys.time(), "] "),
    "Finished smoothMonotoneUMI4C"
  )
  return(dds)
  
}
#' Monotone smoothing of the VST counts
#' 
#' Takes the variance stabilized count values and calculates a symmetric 
#' monotone fit for the distance dependency. The signal trend is fitted using 
#' the \href{https://CRAN.R-project.org/package=fda}{fda} package.
#' @param trafo_counts Variance stabilized count values assay from DDS object.
#' @param frag_data Data frame with all the information on restriction fragments
#'  and the interval around the viewpoint.
#' @return A dataframe with monotone smoothed fit counts. 
#' @details This function computes the smoothing function for the VST values, 
#' based on \href{https://CRAN.R-project.org/package=fda}{fda} package, and 
#' calculates a symmetric monotone fit counts for the distance dependency
#' @inheritParams differentialNbinomWaldTestUMI4C
.smoothMonotone <- function(trafo_counts,
                            alpha=20,
                            penalty=0.1,
                            frag_data){
  
  basisobj <- fda::create.bspline.basis(rangeval=c(min(frag_data$log_dist),max(frag_data$log_dist)),
                                        nbasis = floor(max(nrow(frag_data)/alpha)))
  
  fdParobj <- fda::fdPar(basisobj, 2, penalty)
  
  mono <- fda::smooth.monotone(argvals = frag_data$log_dist,
                               y = trafo_counts, 
                               WfdParobj = fdParobj)
  
  fit <- predict(mono, frag_data$log_dist)
}

#' Z-score calculation using residuals of trend and fit UMI4C counts
#' 
#' Calculates the z-score and then they are converted into one-sided P-values and 
#' adjusted for multiple testing using the method of Benjamini and Hochberg
#' @param dds DDS object as generated by \code{smoothMonotoneUMI4C} with the 
#' smooth monotone fit counts
#' @return DDS object with zscore,pvalue and padjusted assays 
#' @details This function calculates the z-score for each fragment over all samples from the residuals of the 
#' symmetric monotone fit and the median absolute deviation (mad). Z-scores are then converted 
#' into one-sided P-values using the standard Normal cumulative distribution function, 
#' and these are adjusted for multiple testing using the method of Benjamini and Hochberg
#' @export
zscoreUMI4C <- function(dds){
  residuals <- assay(dds, 'trafo') - assay(dds, 'fit')
  sd <- apply(residuals, 2, BiocGenerics::mad)
  zscore <- sweep(residuals, 2, sd, "/")
  pvalue <- apply(zscore, 2, stats::pnorm, lower.tail = FALSE)
  padjusted <- apply(pvalue, 2, stats::p.adjust, method = "BH")
  colData(dds)$sd <- sd
  assays(dds)[["zscore"]] <- zscore
  assays(dds)[["pvalue"]] <- pvalue
  assays(dds)[["padjusted"]] <- padjusted 
  return(dds)
}

#' Significant fragment caller
#' 
addPeaksUMI4C <- function(dds, zscore_thresh = 2, fdr_thresh = 0.1){
  
  zscore <- assay(dds, "zscore")
  fdr <- assay(dds, "padjusted")
  
  peaks = array(FALSE, dim=dim(fdr), dimnames=dimnames(fdr))
  
  for(lvl in levels(colData(dds)$condition)){
    cond_cols <- colData(dds)$condition == lvl 
    tmp <- (apply(fdr[,cond_cols, drop=FALSE] < fdr_thresh, 1, any, na.rm=TRUE) & 
              apply(zscore[,cond_cols, drop=FALSE] > zscore_thresh, 1, all, na.rm=TRUE))    
    ## annotate peaks
    peaks[tmp,cond_cols] = TRUE
  }
  
  assays(dds)[["peaks"]] <- peaks
  
  metadata(dds)$peakParameter <- S4Vectors::DataFrame(zscore_thresh = zscore_thresh, 
                                                      fdr_thresh = fdr_thresh)
  
  return(dds)
}
