#' UMI4C Contacts Processing
#'
#' Using demultiplexed FastQ files as input, performs all necessary steps to end up with a tsv file summarizing the
#' restriction enzyme fragments and the number of UMIs supporting that specific contact with the viewpoint (bait) of
#' interest.
#'
#' @param fastq_dir Path of the directory containing the FastQ files (compressed or uncompressed).
#' @param wk_dir Working directory where to save the outputs generated by the UMI-4c analysis.
#' @param bait_seq Character containing the bait primer sequence.
#' @param bait_pad Character containing the pad sequence (sequence between the bait primer and the restriction enzyme sequence).
#' @param res_enz Character containing the restriction enzyme sequence.
#' @param cut_pos Numeric indicating the nucleotide position where restriction enzyme cuts (zero-based) (for example, for DpnII is 0).
#' @param digested_genome Path for the digested genome file generated using the \code{\link{digestGenome}} function.
#' @param ref_gen Path for the reference genome to use for the alignment (fasta format).
#' @param threads Number of threads to use in the analysis.
#' @details This function is a combination of calls to other functions that perform the necessary steps for processing
#' UMI-4C data.
#' @examples
#' \dontrun{
#' contactsUMI4C(fastq_dir="raw_fastq",
#'               wk_dir="SOCS1",
#'               bait_seq="CCCAAATCGCCCAGACCAG",
#'               bait_pad="GCGCG",
#'               res_enz="GATC",
#'               cut_pos=0,
#'               digested_genome=hg19_dpnii,
#'               ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'               threads=1)
#' }
#' @export
contactsUMI4C <- function(fastq_dir,
                          wk_dir,
                          bait_seq,
                          bait_pad,
                          res_enz,
                          cut_pos,
                          digested_genome,
                          ref_gen,
                          threads=1){

  dir.create(wk_dir, showWarnings=FALSE) # Create working dir
  # cut_pos <- as.character(cut_pos) # convert to character

  prepUMI4C(fastq_dir = fastq_dir,
            wk_dir = wk_dir,
            bait_seq = bait_seq,
            bait_pad = bait_pad,
            res_enz = res_enz)

  splitUMI4C(wk_dir = wk_dir,
             prep_dir = prep_dir,
             res_enz = res_enz,
             cut_pos = cut_pos)

  alignmentUMI4C(wk_dir = wk_dir,
                 bait_seq = bait_seq,
                 bait_pad = bait_pad,
                 res_enz = res_enz,
                 ref_gen = ref_gen,
                 threads = threads)

  counterUMI4C(wk_dir = wk_dir,
               bait_seq = bait_seq,
               bait_pad = bait_pad,
               res_enz = res_enz,
               digested_genome = digested_genome,
               ref_gen = ref_gen)

}

#' Prepare UMI4C data
#'
#' Prepare the FastQ files for the analysis by selecting reads with bait and
#' adding the respective UMI identifier for each read in its header.
#' @inheritParams contactsUMI4C
#' @seealso \code{\link{contactsUMI4C}}
#' @examples
#' \dontrun{
#' prepUMI4C(fastq_dir="raw_fastq",
#'       wk_dir="SOCS1",
#'       bait_seq="CCCAAATCGCCCAGACCAG",
#'       bait_pad="GCGCG",
#'       res_enz="GATC")
#'}
#'
#'@export
prepUMI4C <- function(fastq_dir,
                      wk_dir,
                      bait_seq,
                      bait_pad,
                      res_enz){


  # create directory
  prep_dir <- file.path(wk_dir, 'prep')
  dir.create(prep_dir, showWarnings = F)

  # define variables
  fastq_files <- list.files(fastq_dir,
                            pattern = "\\.fastq$|\\.fq$|\\.fq.gz$|\\.fastq.gz$",
                            full.names = T)

  #TODO: define format of input files
  fastqR1_files <- fastq_files[grep("_R1", fastq_files)]
  fastqR2_files <- fastq_files[grep("_R2", fastq_files)]


  # apply main function to files
  stats <- lapply(1:length(fastqR1_files),
                  function(i) prep(fq_R1=fastqR1_files[i],
                                   fq_R2=fastqR2_files[i],
                                   bait_seq=bait_seq,
                                   bait_pad=bait_pad,
                                   res_enz=res_enz,
                                   prep_dir=prep_dir))

  # create stats file and save
  stats <- do.call(rbind, stats)
  dir.create(file.path(wk_dir, "logs"), showWarnings=FALSE) # Create logs dir
  write.table(stats,
              file = file.path(wk_dir, "logs", "umi4c_stats.txt"),
              row.names = FALSE,
              sep="\t",
              quote=FALSE)
}

#' Prep fastq files at a given barcode.
#' @param fq_R1 Fastq file R1.
#' @param fq_R2 Fastq file R2..
#' @param prep_dir Prep directory.
#' @inheritParams contactsUMI4C
#' @export
prep <- function(fq_R1,
                 fq_R2,
                 bait_seq,
                 bait_pad,
                 res_enz,
                 prep_dir){

  reads_fqR1 <- ShortRead::readFastq(fq_R1)
  reads_fqR2 <- ShortRead::readFastq(fq_R2)

  total_reads <- length(reads_fqR1) # Save total reads

  # filter reads that not present bait seq + bait pad + re -----------
  barcode <- paste0(bait_seq, bait_pad, res_enz)

  barcode_reads_fqR1 <- reads_fqR1[grepl(barcode, ShortRead::sread(reads_fqR1))]
  barcode_reads_fqR2 <- reads_fqR2[grepl(barcode, ShortRead::sread(reads_fqR1))]

  specific_reads <- length(barcode_reads_fqR1) # Save specific reads

  # filter reads with less than 20 phred score --------------------
  filter20phred <- lapply(as(Biostrings::PhredQuality(Biostrings::quality(barcode_reads_fqR1)),
                             'IntegerList'), mean) >= 20 &
    lapply(as(Biostrings::PhredQuality(Biostrings::quality(barcode_reads_fqR2)), 'IntegerList'), mean) >= 20

  filtered_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR1)[filter20phred],
                                               Biostrings::quality(barcode_reads_fqR1)[filter20phred],
                                               ShortRead::id(barcode_reads_fqR1)[filter20phred])

  filtered_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(barcode_reads_fqR2)[filter20phred],
                                               Biostrings::quality(barcode_reads_fqR2)[filter20phred],
                                               ShortRead::id(barcode_reads_fqR2)[filter20phred])

  filtered_reads <- length(filtered_reads_fqR1) # Return num filtered reads

  # insert umi identifier (10 first bp of R2) to header of both R1 R2 files -----------
  umis <- stringr::str_sub(ShortRead::sread(filtered_reads_fqR1), start=1, end=10)

  new_id_R1 <- paste0(umis, ":", "UMI4C:", 1:length(filtered_reads_fqR1))
  new_id_R2 <- paste0(umis, ":", "UMI4C:", 1:length(filtered_reads_fqR2))

  umi_reads_fqR1 <- ShortRead::ShortReadQ(ShortRead::sread(filtered_reads_fqR1),
                                          Biostrings::quality(filtered_reads_fqR1),
                                          Biostrings::BStringSet(new_id_R1))

  umi_reads_fqR2 <- ShortRead::ShortReadQ(ShortRead::sread(filtered_reads_fqR2),
                                          Biostrings::quality(filtered_reads_fqR2),
                                          Biostrings::BStringSet(new_id_R2))

  # write output fastq files

  prep_fastqR1 <- paste0(gsub('\\..*', '', basename(fq_R1)), ".fq.gz")
  prep_fastqR2 <- paste0(gsub('\\..*', '', basename(fq_R2)), ".fq.gz")

  ShortRead::writeFastq(filtered_reads_fqR1, file.path(prep_dir, prep_fastqR1))
  ShortRead::writeFastq(filtered_reads_fqR2, file.path(prep_dir, prep_fastqR2))

  # Construct stats data.frame
  stats <- data.frame(sample_id=strsplit(basename(fq_R1), "_R1")[[1]][1],
                      total_reads=total_reads,
                      specific_reads=specific_reads,
                      filtered_reads=filtered_reads,
                      stringsAsFactors = FALSE)

  return(stats)
}

#' Split UMI4C reads
#'
#' Split the prepared reads using the restrition enzyme information.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' splitUMI4C(wk_dir="SOCS1",
#'        cut_seq_5p="",
#'        cut_seq_3p="GATC")
#' }
#' @export
splitUMI4C <- function(wk_dir,
                       prep_dir = "",
                       res_enz = "GATC",
                       cut_pos = 0){

  # create directory
  prep_dir <- file.path(wk_dir, 'prep')
  split_dir <- file.path(wk_dir, 'split')

  dir.create(split_dir, showWarnings = F)

  prep_files <- list.files(prep_dir,
                           pattern = ".gz$",
                           full.names = T)

  prep_files_R1 <- prep_files[grep("_R1", prep_files)]
  prep_files_R2 <- prep_files[grep("_R2", prep_files)]

  # run main function
  lapply(prep_files_R1, split, res_enz=res_enz, cut_pos=cut_pos, split_dir=split_dir)

  # run main function
  lapply(prep_files_R2, split, res_enz=res_enz, cut_pos=(nchar(res_enz)-cut_pos), split_dir=split_dir)
}

#' Split fastq files at a given restriction site
#' @param fastq_file Fastq file path.
#' @param res_enz Sequence for the restriction enzyme to cut.
#' @param cut_pos Position where RE cuts.
#' @param split_dir Directory where to save split files.
#' @export
split <- function(fastq_file,
                  res_enz,
                  cut_pos,
                  split_dir,
                  min_flen=20){
  # define variables and create objects
  prep_reads <- ShortRead::readFastq(fastq_file)
  prep_dna_string <- ShortRead::sread(prep_reads)

  ids <- ShortRead::id(prep_reads)

  # Find matches for the re sequence
  matches <- Biostrings::vmatchPattern(res_enz, prep_dna_string)
  matches <- as(matches, "CompressedIRangesList")
  IRanges::start(matches) <- as(IRanges::start(matches) - 1,
                                "CompressedIntegerList")
  IRanges::end(matches) <- as(IRanges::end(matches) - (nchar(res_enz) - cut_pos),
                              "CompressedIntegerList")

  gaps <- IRanges::gaps(matches,
                        start=1,
                        end=unique(nchar(as.character(prep_dna_string)))) # workaround for obtaining the cut position

  ids_sel <- gaps
  IRanges::start(ids_sel) <- as(1, "IntegerList")
  IRanges::end(ids_sel) <- as(nchar(as.character(ids)), "IntegerList")

  list_seqs <- Biostrings::extractAt(prep_dna_string, gaps)
  list_quals <- Biostrings::extractAt(Biostrings::quality(Biostrings::quality(prep_reads)), gaps)
  list_ids <- Biostrings::extractAt(ids, ids_sel)

  fastq_entry <- ShortRead::ShortReadQ()
  fastq_entry@sread <- unlist(list_seqs)
  fastq_entry@quality <- ShortRead::FastqQuality(unlist(list_quals))
  fastq_entry@id <- unlist(list_ids)

  # Remove reads shorter than minimum fragment length
  fastq_entry <- fastq_entry[ShortRead::width(fastq_entry)>=min_flen]

  # Write fastq file
  splited_fastq_name <- paste0(gsub("\\..*$", "", basename(fastq_file)), ".fq.gz")
  filename <- file.path(split_dir, splited_fastq_name)

  # Remove file if it already exists to avoid appending new reads
  if (file.exists(filename)) unlink(filename)

  ShortRead::writeFastq(fastq_entry,
                        file=filename,
                        mode="a")
}

#' UMI4C alignment
#'
#' Align splitted UMI-4C reads to a reference genome using Bowtie2.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' alignmentR(wk_dir="SOCS1",
#'            bait_seq="CCCAAATCGCCCAGACCAG",
#'            bait_pad="GCGCG",
#'            res_enz="GATC",
#'            ref_gen="~/data/reference_genomes/hg19/hg19.fa",
#'            threads=1)
#' }
#'
#' @export


alignmentUMI4C <- function(wk_dir,
                           bait_seq,
                           bait_pad,
                           res_enz,
                           ref_gen,
                           threads=1){
  #TODO: error no viewpoint
  # get coordinates of viewpoint using bowtie2
  viewpoint <-  paste0(bait_seq, bait_pad, res_enz)

  # TODO: bowtie index autogeneration if not exist? set automatic bowtie or define path?
  bowtie_index <- gsub('\\.fa$', '', ref_gen)

  view_point_pos <- system(paste(system.file(package="Rbowtie2", "bowtie2-align-s"),
                                 '--quiet',
                                 '-N 0',
                                 '-x', bowtie_index,
                                 '-c', viewpoint),
                           intern = T)


  view_point_pos <- tail(view_point_pos, n = 1)
  view_point_pos <- unlist(strsplit(view_point_pos, "\t"))
  pos_chr <- view_point_pos[3]
  pos_start <- as.numeric(view_point_pos[4])
  pos_end <- pos_start + nchar(viewpoint) - nchar(res_enz)
  pos_viewpoint <- c(pos_chr, pos_start, pos_end)

  #TODO: error no files
  # align splited files
  split_dir <- file.path(wk_dir, 'split')
  align_dir <- file.path(wk_dir, 'align')

  dir.create(align_dir, showWarnings = F)

  gz_files <- list.files(split_dir,
                         pattern = ".gz$",
                         full.names = T)

  #TODO: try except
  sapply(gz_files, R.utils::gunzip)

  splited_files <- list.files(split_dir,
                              pattern = "\\.fastq$|\\.fq$",
                              full.names = T)

  lapply(splited_files,
         align,
         align_dir = align_dir,
         threads = threads,
         bowtie_index = bowtie_index,
         pos_viewpoint = pos_viewpoint)

}

#' Align fastq filee
#' @param fastq_file Fastq file to align.
#' @param align_dir Sequence for the restriction enzyme to cut.
#' @param bowtie_index Bowtie index file for the reference genome.
#' @param pos_viewpoint Vector consist of chromosome, start and end position of the viewpoint.
#' @inheritParams contactsUMI4C
#' @export
align <- function(splited_file,
                  align_dir,
                  threads=1,
                  bowtie_index,
                  pos_viewpoint){

  split_name <- gsub("\\..*$", "", basename(splited_file))
  sam <-  file.path(align_dir, paste0(split_name, ".sam"))
  bam <-  file.path(align_dir, paste0(split_name, ".bam"))
  filtered_tmp_bam <-  file.path(align_dir, paste0(split_name, "_filtered_tmp.bam"))
  filtered_bam <-  file.path(align_dir, paste0(split_name, "_filtered.bam"))

  # align using bowtie2
  suppressMessages(Rbowtie2::bowtie2(seq1 = splited_file,
                                     bt2Index = bowtie_index,
                                     "--threads", threads,
                                     samOutput = sam,
                                     overwrite = TRUE))

  # sam to bam
  Rsamtools::asBam(sam)

  # keep reads in a 10M window from viewpoint
  #TODO: bigger window?
  pos_chr <- pos_viewpoint[1]
  pos_start <-  as.numeric(pos_viewpoint[2])
  pos_end <- as.numeric(pos_viewpoint[3])

  filter_start <- pos_start - 10e6
  filter_end <- pos_end + 10e6
  pos_filter <- paste0(pos_chr, ":", filter_start, "-", filter_end)

  param_10M <- Rsamtools::ScanBamParam(which = GenomicRanges::GRanges(pos_filter))
  Rsamtools::filterBam(bam, filtered_tmp_bam, param = param_10M)

  # filter reads with 42mapq at least
  filter_mapq <- S4Vectors::FilterRules(list(mapq_filter = function(x) x$mapq >= 42))
  Rsamtools::filterBam(filtered_tmp_bam, filtered_bam, filter = filter_mapq, param = Rsamtools::ScanBamParam(what="mapq"))

  # remove sam
  #TODO: remove all the others?
  unlink(sam)
}


#' UMI counting
#'
#' Algorithm for counting  and collapsing the number of UMIs supporting a specific ligation.
#' @inheritParams contactsUMI4C
#' @examples
#' \dontrun{
#' umiCounterR(wk_dir="SOCS1",
#'             bait_seq="CCCAAATCGCCCAGACCAG",
#'             bait_pad="GCGCG",
#'             res_enz="GATC",
#'             digested_genome=hg19_dpnii,
#'             ref_gen="~/data/reference_genomes/hg19/hg19.fa")
#' }
#' @details For collapsing different molecules into the same UMI, takes into account the ligation position and
#' the number of UMI sequence mismatches.
#' @export
counterUMI4C <- function(wk_dir,
                         bait_seq,
                         bait_pad,
                         res_enz,
                         digested_genome,
                         ref_gen){

  align_dir <- file.path(wk_dir, 'align')
  count_dir <- file.path(wk_dir, 'count')
  dir.create(count_dir, showWarnings = F)

  # get coordinates of viewpoint using bowtie2
  viewpoint <-  paste0(bait_seq, bait_pad, res_enz)

  # TODO: bowtie index autogeneration if not exist? set automatic bowtie or define path?
  bowtie_index <- gsub('\\.fa$', '', ref_gen)

  view_point_pos <- system(paste(system.file(package="Rbowtie2", "bowtie2-align-s"),
                                 '--quiet',
                                 '-N 0',
                                 '-x', bowtie_index,
                                 '-c', viewpoint),
                           intern = T)


  view_point_pos <- tail(view_point_pos, n = 1)
  view_point_pos <- unlist(strsplit(view_point_pos, "\t"))
  pos_chr <- view_point_pos[3]
  pos_start <- as.numeric(view_point_pos[4])
  pos_end <- pos_start + nchar(viewpoint) - nchar(res_enz)
  pos_viewpoint <- c(pos_chr, pos_start, pos_end)

  # define variables
  aligned_files <- list.files(align_dir,
                              pattern = "_filtered.bam$",
                              full.names = T)

  #TODO: define format of input files
  alignedR1_files <- aligned_files[grep("_R1", aligned_files)]
  alignedR2_files <- aligned_files[grep("_R2", aligned_files)]

  lapply(1:length(alignedR1_files),
         function(i) count(filtered_bam_R1=alignedR1_files[i],
                           filtered_bam_R2=alignedR2_files[i],
                           digested_genome=digested_genome,
                           pos_view=pos_viewpoint,
                           count_dir=count_dir))
}


#' Counts umis for a given bam file.
#' @param filtered_bam_R1 R1 bam file,
#' @param filtered_bam_R2 R2 bam file,
#' @param bowtie_index Bowtie index file for the reference genome.
#' @param pos_viewpoint Vector consist of chromosome, start and end position of the viewpoint.
#' @param count_dir Counter directory.
#' @inheritParams contactsUMI4C
#' @export
count <- function(digested_genome,
                  pos_viewpoint,
                  filtered_bam_R1,
                  filtered_bam_R2,
                  count_dir){
  # count UMIs for every ligation

  # get coordinates of viewpoint using bowtie2
  pos_chr <- pos_viewpoint[1]
  pos_start <-  as.numeric(pos_viewpoint[2])
  pos_end <- as.numeric(pos_viewpoint[3])
  filter_bp <- 10e6
  filter_start <- pos_start - filter_bp
  filter_end <- pos_end + filter_bp

  #TODO: ignore.strand=FALSE ???
  # load digest genome, filter and transform to granges
  digested_genome <- read.csv(digested_genome, sep = '\t', header = F)
  colnames(digested_genome) <- c('chr', 'start', 'end')
  digested_genome <- digested_genome[(digested_genome$chr == pos_chr) &
                                       (digested_genome$start >= filter_start) &
                                       (digested_genome$end <= filter_end),]

  rownames(digested_genome) <- seq(nrow(digested_genome))
  digested_genome_gr <- GenomicRanges::GRanges(seqnames = digested_genome$chr, IRanges::IRanges(digested_genome$start,
                                                                                                digested_genome$end),
                                               strand = "+")
  # read bam and transform to a granges
  bam_R1_gr <- GenomicAlignments::readGAlignments(filtered_bam_R1, use.names=TRUE)
  bam_R2_gr <- GenomicAlignments::readGAlignments(filtered_bam_R2, use.names=TRUE)

  # relay segments and fragments for both bams
  hits <- GenomicAlignments::findOverlaps(bam_R1_gr, digested_genome_gr)
  frags_R1_gr <- digested_genome_gr[S4Vectors::subjectHits(hits),]
  frags_R1 <- data.frame(frags_R1_gr)
  colnames(frags_R1) <- c('chr_frag', 'start_frag', 'end_frag')
  frags_R1 <- frags_R1[c('chr_frag', 'start_frag', 'end_frag')]
  segments_R1_gr <- bam_R1_gr[S4Vectors::queryHits(hits),]
  segments_R1_gr <- data.frame(segments_R1_gr)
  segments_R1_gr$header <- rownames(segments_R1_gr)
  rownames(segments_R1_gr) <- seq(nrow(segments_R1_gr))
  segments_R1_gr <- segments_R1_gr[c('seqnames', 'start', 'end', 'header')]
  frags_segments_R1 <- cbind(segments_R1_gr, frags_R1)
  frags_segments_R1$header <- as.character(frags_segments_R1$header)


  hits <- GenomicAlignments::findOverlaps(bam_R2_gr, digested_genome_gr)
  frags_R2_gr <- digested_genome_gr[S4Vectors::subjectHits(hits),]
  frags_R2 <- data.frame(frags_R2_gr)
  colnames(frags_R2) <- c('chr_frag', 'start_frag', 'end_frag')
  frags_R2 <- frags_R2[c('chr_frag', 'start_frag', 'end_frag')]
  segments_R2_gr <- bam_R2_gr[S4Vectors::queryHits(hits),]
  segments_R2_gr <- data.frame(segments_R2_gr)
  segments_R2_gr$header <- rownames(segments_R2_gr)
  rownames(segments_R2_gr) <- seq(nrow(segments_R2_gr))
  segments_R2_gr <- segments_R2_gr[c('seqnames', 'start', 'end', 'header')]
  frags_segments_R2 <- cbind(segments_R2_gr, frags_R2)
  frags_segments_R2$header <- as.character(frags_segments_R2$header)

  # define fragment viewpoint
  view_point_pos_gr <- GenomicRanges::GRanges(seqnames = pos_chr, IRanges::IRanges(pos_start, pos_end))
  hits <- GenomicAlignments::findOverlaps(view_point_pos_gr, digested_genome_gr)
  view_point_frag_gr <- digested_genome_gr[S4Vectors::subjectHits(hits),]
  view_point_frag <- data.frame(view_point_frag_gr)
  view_point_frag <- view_point_frag[c(1,2,3)]
  colnames(view_point_frag) <- c('chr_frag', 'start_frag', 'end_frag')

  # categorize fragments into viewpoint fragment and contact fragment
  frags_segments_viewpoint <- dplyr::inner_join(frags_segments_R1, view_point_frag)
  frags_segments_contact <- dplyr::anti_join(frags_segments_R1, view_point_frag)
  frags_segments_contact <- rbind(frags_segments_contact, frags_segments_R2)

  # generate ligations
  ligations <- dplyr::left_join(frags_segments_viewpoint, frags_segments_contact, by = 'header')
  ligations <- data.frame(na.omit(ligations))
  ligations$umi <- lapply(ligations$header, function(x) unlist(strsplit(x, ":"))[1])
  ligations$header <- NULL
  ligations$seqnames.x <- NULL
  ligations$start.x <- NULL
  ligations$end.x <- NULL

  colnames(ligations) <- c('chr_bait', 'start_bait', 'end_bait',
                           'chr_seq_contact','start_seq_contact', 'end_seq_contact',
                           'chr_fraq_contact','start_fraq_contact', 'end_fraq_contact',
                           'UMIs')

  # collapse ligations with the same positions
  ligations_filter_pos <- ligations[!duplicated(ligations[c('chr_seq_contact','start_seq_contact', 'end_seq_contact')]),]

  # collapse ligations with less than 2 mismatches
  collapsed_umis <- c()
  umi_list <- ligations_filter_pos$UMIs

  while (length(umi_list) > 0) {

    compared_umi <- umi_list[[1]]
    collapsed_umis <- c(collapsed_umis, compared_umi)
    umi_DNAString <- Biostrings::DNAStringSet(unlist(umi_list))
    matches <- Biostrings::vcountPattern(compared_umi, umi_DNAString, max.mismatch = 2)
    umi_list <- umi_list[!as.logical(matches)]

  }

  collapsed_umis <- data.frame(collapsed_umis)
  colnames(collapsed_umis) <- 'UMIs'
  collapsed_umis$UMIs <- as.character(collapsed_umis$UMIs)
  ligations_filter_pos$UMIs <- as.character(ligations_filter_pos$UMIs)

  # count umis for every position in the filtered digested genome
  ligations_filter_pos_umi <- dplyr::inner_join(ligations_filter_pos, collapsed_umis)

  ligations_filter_pos_umi <- ligations_filter_pos_umi[c('chr_bait', 'start_bait',
                                                         'chr_fraq_contact', 'start_fraq_contact',
                                                         'UMIs')]

  colnames(ligations_filter_pos_umi) <- c('chr_bait', 'pos_bait',
                                          'chr_contact', 'pos_contact',
                                          'UMIs')



  ligations_filter_pos_umi <- unique(ligations_filter_pos_umi)
  counts_umi4c <- ligations_filter_pos_umi[c("chr_bait", "pos_bait", "chr_contact", "pos_contact")]

  counts_umi4c <- data.frame(table(apply(counts_umi4c, 1, paste0, collapse="_")))
  colnames(counts_umi4c) <- c('tmp', 'UMIs')

  counts_umi4c <- tidyr::separate(data = counts_umi4c, col = tmp, c('chr_bait', 'pos_bait',
                                                                    'chr_contact', 'pos_contact'),
                                  sep = "_")


  digested_genome <- digested_genome[c('chr', 'start')]
  colnames(digested_genome) <- c('chr_contact', 'pos_contact')
  digested_genome$chr_bait <- view_point_frag[[1]]
  digested_genome$pos_bait <- view_point_frag[[2]]

  digested_genome <- digested_genome[c('chr_bait', 'pos_bait',
                                       'chr_contact', 'pos_contact')]


  counts_umi4c[c(1:ncol(counts_umi4c))] <- sapply(counts_umi4c[c(1:ncol(counts_umi4c))], as.character)
  digested_genome[c(1:ncol(digested_genome))] <- sapply(digested_genome[c(1:ncol(digested_genome))], as.character)
  umi_output <- dplyr::left_join(digested_genome, counts_umi4c)
  umi_output$UMIs[is.na(umi_output$UMIs)] <- 0

  # save counts
  file_name <- strsplit(basename(filtered_bam_R1), "_R1")[[1]][1]
  counts_file <- file.path(count_dir, paste0(file_name, '_counts.tsv'))

  write.table(x = umi_output,
              file = counts_file,
              row.names = F,
              quote = F,
              sep = '\t')

}
